---
tags:
    - AntBook
---

# 重要なこと

## ヒープ(プライオリティキュー，順位キュー，優先度付き待ち行列)

・数値を追加する

・最小(最大)の数値を取り出す(取り出すというのは値を取得して削除すること)

## 二分探索木(set,map)

・数値を追加する

・ある数値が含まれているかを調べる

・ある数値を削除する

・最小値，最大値，ソートができる（intは勿論，キーがstringやcharなら辞書順にも並べることができる）

（因みにだが,stringの辞書順を考える場合，空白はaの上である．つまりasdfg,asdfを辞書順に並べるとasdf,asdfgになるaazzzとabaaとかのでも並べたらaazzz,abaaという並びになる）


## Union-Find木

 グループ分けができる

・要素aと要素bが同じグループに属するかを調べる

・要素aと要素bのグループを併合する

・注意:グループの分割はできない


# ヒープ

自分で作るよりプライオリティーキューのライブラリー使った方が早い，次に蟻本のコードが早い

ライブラリーのプライオリティキューは大きい順にpopするのだが，小さい順にpopするには以下のように定義すればよい

```
    priority_queue<int, vector<int>, greater<int> > queue;
```

# 2分探索木

削除に関しては茨木本が圧倒的に分かりやすい．

setもmapもfind(key)でキーのイテレータを検索したとき，そのキーが存在しない場合はend()のイテレータを返す

同じキーを複数格納可能なmultiset，multimap等も存在する

mapのインサートの仕方として，キーと値を入れないといけないのでmake_pairでpair型で追加しなければならない

setもmapも要素の全列挙の仕方はfindした時になければend()を返すという仕様を利用してループを作る

setを使った場合，このループを行うと昇順にソートされている．つまり最初のイテレータは最小値を示していて最後のイテレータは最大値を示している．

mapを使った場合，このループを行うとキーに対して昇順にソートされている．

このset，mapにおいてのソートや最小値，最大値はキーを辞書順に並べたときのソート，最初の値，最後の値を意味している．キーの型がintなら分かりやすい．charやstringなら辞書順に並んでいる．

使い方は蟻本を見ればいいと思う

setはキーのみを保持していて，重複を許さない

mapはキーと値を保持するので重複してもよい

・使い方URL

https://programgenjin.hatenablog.com/entry/2019/03/02/141225#f-b0cf16c2

https://cpprefjp.github.io/reference/set/set.html

https://cpprefjp.github.io/reference/map/map.html


# Union-find木

一回一回の操作はO(α(n))となり，これはO(log n)よりも早い

# Food Chain(食物連鎖)
## 蟻本のタイプ1と2についての説明

[xがAの場合]と[YがAの場合]を同じグループにするというのは，X in A⇔Y in A にするという意味なので

タイプ1:[xがAの場合]と[YがAの場合]を同じグループ，[xがBの場合]と[YがBの場合]を同じグループ，[xがCの場合]と[YがCの場合]を同じグループ

タイプ2:[xがAの場合]と[YがBの場合]を同じグループ,[xがBの場合]と[YがCの場合]を同じグループ,[xがCの場合]と[YがAの場合]を同じグループ

とするという意味である．

## 情報が間違っているかどうかを判定するif文(ansをインクリメントするかしないかのif文)についての説明

そもそもUnion-findの初期化は，要素ごとのグループに分けているので，例えば1は1はグループだし，2は2のグループだし，3は3のグループなのである．

最初はそのように格納されているので，どこかのA,B,Cのように，3つのグループに最初から分かれているわけではない．つまり，既に情報によってグループ分けされているかどうかが分かるので，以下のような判定で，今参照してる情報が既に参照した情報と比較した場合に，間違っているのかが分かる．

つまり，「まだグループ分けがされてない」 or 「グループ分けされてるけどそのグループと今参照してる情報が一致してる」という場合なら，上のようにタイプごとに併合していき，「既にグループ分けされてて，そのグループが今参照してる情報と一致しない」となる場合は，今参照してる情報が間違っているとしてans++する．

タイプ1:X in A⇔Y in B　または　X in A⇔Y in C　と(既に)なっていたらこれは間違った情報である

タイプ2:X in A⇔Y in A　または　X in A⇔Y in C　と(既に)なっていたらこれは間違った情報である

