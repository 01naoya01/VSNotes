---
tags:
    - AntBook
---

グラフの例はこの図

http://www.deqnotes.net/acmicpc/dijkstra/

# 隣接行列と隣接リストについて

隣接行列は2次元配列で実現可能

隣接リストはソースコードに示した方法で実現可能

蟻本にもある通り，隣接行列は確保するメモリ量が多いが，隣接リストはその心配はない．

ただ，隣接行列なら2次元配列で実現できているので，例えばiからjに辺があるかどうかの確認はg[i][j]の中身を参照するだけでいいので，計算量は必要ない

しかし，隣接リストの場合は，iのリストを走査しなければならない，つまり最悪時間でO(n)かかる (この計算時間量はiのリストに全ての頂点が入っていた場合，要するにiから全ての頂点に辺を持っていた場合)

# 隣接リストの実現方法について
実現方法2は頂点に属性を与える場合のみに使う．

頂点に属性を与えたいわけではないなら，どのような場合でも実現方法1を使うべきであると思う．

実現方法2に関しては構造体の中に構造体を要素として配列を入れて，辺を実現する．そのような構造体を要素とする配列が隣接リストになる．

つまりその隣接リストの頂点を構造体として定義しているのでその構造体に頂点の属性を入れることができる．

# 2-5の隣接リストの実現方法2の構造体について

G[]の各要素が構造体vertexになってる
↓
ってことは各要素にedge[]とcostを持ってる
↓
そのedge[]の各要素は構造体vertexのポインタになってる

だからedge[]には他のvertexのポインタを格納する

G[s].edge.push_back(&G[t]);

↑つまりこれはG[s]のedge[] の最後尾にG[t]のポインタを入れている.それができるのは，edge[]の各要素がvertex型のポインタを格納するように定義しているからである 

# DFSを使って連結判定や閉路判定について

連結判定は，二部グラフ判定の時のように，色なしを0で色付きを1として，とある頂点からdfsで塗っていって，dfsが終わったら塗ってない色がないかを確認する．もし塗ってない色があれば，それはdfsで塗れなかった色で，その頂点は別の連結成分である．

閉路の場合は，辺にチェックをつけていって，dfs中にチェック済みの辺があれば閉路があったといえる．

# ベルマンフォードとダイクストラにおいての負閉路について

負閉路があれば，ベルマンフォードでもダイクストラでも正しい最短路を求めることはできない

ただ，負閉路があればベルマンフォードは負閉路があるよって検出できる(ダイクストラは検出できず，ただただ間違った値が出てくる)

なお，負閉路がなくても負の辺はあるって場合もあると思うが，ベルマンフォードは負の辺はあっても正しい結果を出力できるが，ダイクストラは負の辺があったら正しい値がでない

しかし，計算量はダイクストラの方が早いので，負の辺がないと分かっているならダイクストラを使った方がいい

# 