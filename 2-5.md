---
tags:
    - AntBook
---

# 隣接行列と隣接リストについて

隣接行列は2次元配列で実現可能

隣接リストはソースコードに示した方法で実現可能

蟻本にもある通り，隣接行列は確保するメモリ量が多いが，隣接リストはその心配はない．

ただ，隣接行列なら2次元配列で実現できているので，例えばiからjに辺があるかどうかの確認はg[i][j]の中身を参照するだけでいいので，計算量は必要ない

しかし，隣接リストの場合は，iのリストを走査しなければならない，つまり最悪時間でO(n)かかる (この計算時間量はiのリストに全ての頂点が入っていた場合，要するにiから全ての頂点に辺を持っていた場合)

# 隣接リストの実現方法について
実現方法2は頂点に属性を与える場合のみに使う．

頂点に属性を与えたいわけではないなら，どのような場合でも実現方法1を使うべきであると思う．

実現方法2に関しては構造体の中に構造体を要素として配列を入れて，辺を実現する．そのような構造体を要素とする配列が隣接リストになる．

つまりその隣接リストの頂点を構造体として定義しているのでその構造体に頂点の属性を入れることができる．

# 2-5の隣接リストの実現方法2の構造体について

G[]の各要素が構造体vertexになってる
↓
ってことは各要素にedge[]とcostを持ってる
↓
そのedge[]の各要素は構造体vertexのポインタになってる

だからedge[]には他のvertexのポインタを格納する

G[s].edge.push_back(&G[t]);

↑つまりこれはG[s]のedge[] の最後尾にG[t]のポインタを入れている.それができるのは，edge[]の各要素がvertex型のポインタを格納するように定義しているからである 