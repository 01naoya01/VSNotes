---
tags:
    - AntBook
---

# 線分上の格子点をgcdでなぜ求められるのか

線分の傾きを考えれば非常に分かりやすい．

簡単のために片方の点を原点(0,0)で考えて，もう片方の点を(a,b)とする．

a,bが互いに素な場合，線分上の点はない．

傾きで考えたとき，例えばa=4,b=3とかの場合，傾きは3/4となる．

完全に約分しきった状態で分子と分母の両方が1じゃないということは，線分上の点を通らないことになる．

言葉で説明しにくいが，図を描いたり，考えたりすれば分かると思う．

逆に互いに素じゃない場合，a=2,b=4とかだったら傾きは4/2=2となる．

で，(2,4)から(0,0)の間で線分上の点は2個になる．

# gcdとgcdの計算量について

gcdそのものについては茨木本が分かりやすい．

茨木本が理解できたら疑似コードと蟻本のコードが同じ意味を示しているのも分かる．

なお，茨木本だとa>bを仮定していたが，もしb>aだとしても蟻本のコードだったら一回の再帰でaとbが逆になるので，蟻本の場合だとどちらが大きいかは気にしなくてよい

計算量についてはwordを見た方が分かりやすいと思う．

結局計算量はa,bの最大公約数を求めるとするなら，O(log max(a,b))となる

# 拡張ユークリッドの互除法について

参考URLの3-4を見るのが一番手っ取り早いと思う

exgcdを渡したときに，返ってくるのは結局gcd(a,b)やけど，渡した変数のx,yに整数解を格納してくれてるっていう関数である

プログラム部分の理解としては，蟻本の方が分かりやすいと思う．

exgcdのyとxが逆になってる部分と，y-=(a/b)*xの部分については，蟻本の下から2つ目の式「これを代入すると～」の所の式を見れば分かると思う

x=y' , y=x'-(a/b)*y'となっている

x=y'なので，y=x'-(a/b)*xとなって，x'はyのことを示している(x'=yとなっているわけではない)．よってこのプログラムのような感じになっている．

要するにxとyは参照型なのでx'の参照しているものはyで，y'の参照しているものはxということである．尚且つx=y'というだけで，x'=yというわけではないということである．

記号の都合でめっちゃ分かりにくいとは思うが，次のページの帰納法の証明のところも読めば雰囲気くらいは掴めるはず

計算量としては再帰の仕方的にgcdと同じである

~補足~

一応説明するが，蟻本の方で最後の式でa=gcd(a,b)となっているが，これはアルゴリズム的にb=0ということはgcdと全く同じようにaに最大公約数が入っているからである

参考URL

https://qiita.com/drken/items/b97ff231e43bce50199a

# 素数判定，約数列挙，素因数分解について

蟻本の素数判定の説明を読んでそれを約数列挙，素因数分解にも適用すれば理解できるとは思うが一応補足しておく．

約数列挙のソースにif(i!=n/i)res.push_back(n/i)という部分がある．

これは，要するにnに対して√nがもし素数なら√nも約数であるが，nの約数aに対してn/aは√nを中心としてaとは対称の数字になる

例えば20の約数4に対して20/4=5だが，これはちゃんと√20=2√5を基準として対称の関係になっている．

だから√nの計算量でもこの文があればちゃんと約数を全て列挙できる．

素因数分解のmapは，各要素に，番号を素数として数字の数を表している

例えば20を素因数分解すればmap変数の名前をaとすると

a[2]=2　a[5]=1　となる

# エラトステネスの篩の計算量について

forのループ回数はn回である．問題はforの中の素数の倍数をfalseにするループの計算量である．

素数である2で篩落とすのにn/2回，3で篩落とすのにn/3回，5で篩落とすのにn/5回…の演算を行うので計算量は

n/2+n/3+n/5+…

となる．素数の逆数和となる．

素数の逆数和は発散するが，その発散の速度がだいたいloglognとなることが知られている．

よってn×loglogn=O(n loglogn)となる．

# 区間内の素数の個数について

エラトステネスの篩を前問のようにそのまま使うことはメモリ的にできない

b未満の整数，つまりcをc < bとなるような整数とする．

d=min{d_i | cの素因数} , e=min{e_i | bの素因数}　とする．

つまりdはb未満の整数の最小の素因数，eはbの最小の素因数である．

eはbの最小の素因数なのでe≦√bとなる．c < bなのでd≦eとなる．

d≦e≦√bとなって，d≦√bを証明できる．

[2, √b)までの数字の倍数を全て取り除けば残った[a,b)の区間に残った数字は全て素数となる．

これは，b未満の整数の最小の素因数が√b以下なので，素因数を持った数字を全て除けるということになる．

もっと詳しく言うと，2から√bまでの数字の倍数を除けば，残る数字は1と√bからbまでの数字で割り切れた数，つまり素数だけが残るからである．

# 割り算について
## 公式

・a≡c(mod m) 尚且つb≡d(mod m)とすると必要十分条件は
a+b	≡c+d	(mod m)
a-b	≡c-d	(mod m)
a×b≡c×d	(mod m)

・a×c≡b×c(mod m)　⇒　a≡b(mod m/gcd(m,c))  もしかしたら⇔かも?

・ab≡ac(mod m)尚且つaとmが互いに素 ⇒ b≡c(mod m)

## 性質

足し算引き算掛け算は普通の等式と同じように扱ってよい．

割り算に関してだが，合同式の両辺をaで割っていいのはaとmが互いに素である場合のみということである．

その他の公式や，上記の公式の説明は，蟻本か下記の参考URLを見た方が早いと思う

参考URL

https://mathtrain.jp/mod

# mod_powについて

ソースコードの順番的にx^2^kのkが偶数の時だけresにかけるって感じである．

奇数のnが来ても最初にresにxを掛けるので問題はない

例えばx^6を求めたいとしたら　x^2 * x^4　となるし

x^7 を求めたいとしたら　　　 x * x^2 *x^4となる

x^8だったら x^8をかけることになる

8/2=4 , 4/2=2 , 2/2=1のこの三回目の時にresに書けられるので3回ということはx^2^kのkが3回なのでx^8となる

ループ回数についてだが，半分づつに減っていくのでlog nである

要するにn=2^kなのでlog n=kとなる

このk回ループするのでO(log n)となる

mod_pow1も2も同じ考え方