---
tags:
    - AntBook
---

# 線分上の格子点をgcdでなぜ求められるのか

線分の傾きを考えれば非常に分かりやすい．

簡単のために片方の点を原点(0,0)で考えて，もう片方の点を(a,b)とする．

a,bが互いに素な場合，線分上の点はない．

傾きで考えたとき，例えばa=4,b=3とかの場合，傾きは3/4となる．

完全に約分しきった状態で分子と分母の両方が1じゃないということは，線分上の点を通らないことになる．

言葉で説明しにくいが，図を描いたり，考えたりすれば分かると思う．

逆に互いに素じゃない場合，a=2,b=4とかだったら傾きは4/2=2となる．

で，(2,4)から(0,0)の間で線分上の点は2個になる．

# gcdとgcdの計算量について

gcdそのものについては茨木本が分かりやすい．

茨木本が理解できたら疑似コードと蟻本のコードが同じ意味を示しているのも分かる．

なお，茨木本だとa>bを仮定していたが，もしb>aだとしても蟻本のコードだったら一回の再帰でaとbが逆になるので，蟻本の場合だとどちらが大きいかは気にしなくてよい

計算量についてはwordを見た方が分かりやすいと思う．

結局計算量はa,bの最大公約数を求めるとするなら，O(log max(a,b))となる

# 拡張ユークリッドの互除法について

参考URLの3-4を見るのが一番手っ取り早いと思う

exgcdを渡したときに，返ってくるのは結局gcd(a,b)やけど，渡した変数のx,yに整数解を格納してくれてるっていう関数である

プログラム部分の理解としては，蟻本の方が分かりやすいと思う．

exgcdのyとxが逆になってる部分と，y-=(a/b)*xの部分については，蟻本の下から2つ目の式「これを代入すると～」の所の式を見れば分かると思う

x=y' , y=x'-(a/b)*y'となっている

x=y'なので，y=x'-(a/b)*xとなって，x'はyのことを示している(x'=yとなっているわけではない)．よってこのプログラムのような感じになっている．

要するにxとyは参照型なのでx'の参照しているものはyで，y'の参照しているものはxということである．尚且つx=y'というだけで，x'=yというわけではないということである．

記号の都合でめっちゃ分かりにくいとは思うが，次のページの帰納法の証明のところも読めば雰囲気くらいは掴めるはず

計算量としては再帰の仕方的にgcdと同じである

~補足~

一応説明するが，蟻本の方で最後の式でa=gcd(a,b)となっているが，これはアルゴリズム的にb=0ということはgcdと全く同じようにaに最大公約数が入っているからである

参考URL

https://qiita.com/drken/items/b97ff231e43bce50199a

# 素数判定，約数列挙，素因数分解について

蟻本の素数判定の説明を読んでそれを約数列挙，素因数分解にも適用すれば理解できるとは思うが一応補足しておく．

約数列挙のソースにif(i!=n/i)res.push_back(n/i)という部分がある．

これは，要するにnに対して√nがもし素数なら√nも約数であるが，nの約数aに対してn/aは√nを中心としてaとは対称の数字になる

例えば20の約数4に対して20/4=5だが，これはちゃんと√20=2√5を基準として対称の関係になっている．

だから√nの計算量でもこの文があればちゃんと約数を全て列挙できる．

素因数分解のmapは，各要素に，番号を素数として数字の数を表している

例えば20を素因数分解すればmap変数の名前をaとすると

a[2]=2　a[5]=1　となる

# 区間内の素数の個数について

エラトステネスの篩を前問のようにそのまま使うことはメモリ的にできない．

forのループ回数はn回である．問題はforの中の素数の倍数をfalseにするループの計算量である．

素数である2で篩落とすのにn/2回，3で篩落とすのにn/3回，5で篩落とすのにn/5回…の演算を行うので計算量は

n/2+n/3+n/5+…

となる．素数の逆数和となる．

素数の逆数和は発散するが，その発散の速度がだいたいloglognとなることが知られている．

よってn×loglogn=O(n loglogn)となる．
