---
tags:
    - AntBook
---

# 01ナップサック問題
p54の漸化式に置き換えても計算量が同じなのは，表のiとjは品物の数と重さを表していて，それを掛け算すれば表のマスの数と同じ数になる，つまり表を作るための計算と同じになる，だからO(nW)

# 最長共通部分列問題 (LCS:Longest Common Subsequence)
LCSは問題文をちゃんと読んだ方がいい，部分文字列は連続した文字列である必要がないことに注意しないといけない
LCSの漸化式についてだが，(それ以外)のところは問題ないが，(s_i+1=t_j+1)の場合のところは，dp[i][j+1]とdp[i+1][j]は省略してよい

# 個数制限なしナップサック問題 (knapsack)
ナップサック問題を見ればわかるが，漸化式と用いた動的計画法で解く場合，考え方として，dp[i+1][j]=i番目までの品物から重さの総和がj以下となるように選んだもの，とある．要するに1ずつjを増加させ，その時その時の最大を求めていく感じである．そして最終的にj=wの場合の最大が元々求めたかったものなので正解になる．この感じはメモ化と同じような感覚である．

p59の式について考える．この最初の式の

dp[i+1][j]=max{dp[i][j-k×w[i]]+k×v[i] | 0<=k}

この式をどうしたいかというと，kのループが嫌なのでこれをなくしたい．これは漸化式なので，漸化式を解くという基本的な気持ちに戻って考える，つまりこの式を式変形して，この式を利用するようにすればよい
この文で意味は分からないかもしれないが，以下を見れば分かるんじゃないかと思う．

dp[i+1][j]=max{dp[i][j-k×w[i]]+k×v[i] | 0<=k} = max(dp[i][j],max{dp[i][j-k×w[i]]+k×v[i] | 1<=k>})       …☆

この式変形は，単純にk=0だった場合についてmaxで分けてるだけである.この状態で，maxの右だけを変形して0<=kにすれば，元の式の形式になるので代入できる．(要するに次は0<=kを目指す>)

=max(dp[i][j],max{dp[i][(j-w[i])-k×w[i]] | 0<=k>}+v[i])

これはなぜこうなるかというと，式変形の目的からすれば，☆の式のk=1の場合が上の式のk=0の場合に一致するようにすればいい☆でk=1の場合はmaxの中は　dp[i][j-w[i]]+v[i]となる．これが目指す式(つまり上の式)のk=0の場合である．よって上のような式になる．v[i]が外に出せるのは，maxなので全部にv[i]足されてるもののmaxなのでv[i]を外に出しても問題は全くない．

そして次はmaxの中のmaxを最初の式の形式になっていることに気づいて代入する
つまり  dp[i+1][j-w[i]]+v[i]=max{dp[i][(j-w[i])-k×w[i]]+k×v[i] | 0<=k}+v[i]   であることに気づく，そして代入すると

=max(dp[i][j],dp[i+1][j-w[i]]+v[i])となる

# DPにおける配列の再利用
配列の再利用の話は，要するに漸化式の表を見れば分かるが，→の向き的に1行のみ保持してる状態でもなんとかなるから，再利用といわれている．ループの向きが違うのはその表の矢印の向きが逆だからである．
再利用という言葉の意味はそういう感じである．中に入ってる値を再利用というよりは，メモリ的な意味でもう一回その領域を使うって感じである．そういう意味が分かればコラムの再利用も本の説明も読んだうえで，なんとなく分かると思う．


# 01ナップサックその2
なぜINFが必要かというと，今まではj以下だったから組合せがないってことはないけど，今回はjに指定してるからこういうことになる．なぜ今回はjに指定してるかというと，今回は価値をjにしてる．今までは重さをjにしてて，重さの制限があったからj以下という風にしていたけど，価値に制限があるわけではないので価値がj以下とかにすると求めるのは最小の重さになるので，中に入る値が小さい値ばっかりになってしまう．だからjに指定してる．
最後のansの求め方でdp[num][i]になっている．numは固定しないといけない理由は，要するにnum個の品物を選んだ時の合計価値iの場合の最小の重さが中にはいってて，その重さが制限を満たしてて一番大きい価値iをansにいれているからである．

# 個数制限付き部分和問題 (Partial Sum Problem with limited number)
P62のboolをDPにしたやつの計算量を考える．ループのnとKを逆にすると考えやすいのだが，逆にすればO(Knm_i)となる．各iのm_iがn個あるのだからO(KΣm)になる
改良版の説明はソースコードに追記してる

# 最長増加部分列問題 (LIS:Longest Increasing Subsequence)
P64の下の解き方は，ソースコードを見れば分かると思うが，i < jを保った状態で，dp[i-1]よりも大きいdata[j]に対してdp[i]の中にminを取っている．dp[i-1]の意味は長さがiであるような増加部分列における最終要素の最小値であるから．だからそのiより添え字が大きく値も大きくて最小の要素を入れてる．
lower_boundを使う方法は本を読めばわかると思う．

# 分割数 (Spilit number)
{a_i-1}はa_iはm個あって全部1づつ引いてるので合計でm個引いてるからn-mのm分割であることになる．その要領でやっていけば次も分かる．a_i=0となるiがあればnぬm-1分割になる．これは0なのでnは変わらないが，分割数は1つ減らせるのでm-1になる．
あとの解説は以下のURLを参照した方がいい．消えたら困るので1個目のURLの中身を貼っておく．
http://techtipshoge.blogspot.com/2011/01/blog-post_28.html
http://whiled.hatenablog.com/entry/2018/03/10/041520
まず、dp[i][j]を整数jをi個以下に分割するパターン数とする。
jをi個以下に分割するパターンは、jをi-1個以下に分割するパターンとjをi個に分割するパターンの和である。ここで、前者の「jをi-1個に分割するパターン」はdp[i-1][j]と書ける。

次に後者。「jをi個に分割するパターン」は、予めi個を1個ずつi個の集合に割り当てて、残ったj-i個をこの集合に割り当てるパターンを考えればいいと分かる。
ちょっと、ややこしいので例題を。
10個を4個に分けるパターンは、まず集合が4ついるので、それぞれの集合に1個ずつ割り当てる。
1, 1, 1, 1
あとは、残った6個をこの4つの集合に割り振るパターン数を考えればよい。
例えば、
6, 0, 0, 0
1, 1, 1, 3
2, 2, 0, 2
などが考えられる。
これを、予め作っておいた集合
1, 1, 1, 1に加えれば4つに分割するパターンが出来ることがわかる。よって、「jをi個に分割するパターン」は、dp[i][j-i]と書ける。

以上の議論から、
dp[i][j] = dp[i-1][j] + dp[i][j-i]
という漸化式が得られる。これはDPを使えば、O(n*m)で解けます。

# 重複組合せ (Duplicate Combination)
漸化式の変形の正当性を説明して，そのあとどういう風に考えたらそういう変形にたどり着くかを説明する．

まず

・kが0からmin(j,a[i])のΣについて

jが選ばれた場合     Σ = dp[i][j] + dp[i][j-1] + … + dp[i][j-j+2] + dp[i][j-j+1] + dp[i][0]
                                                          =2             =1

a[i]が選ばれた場合  Σ = dp[i][j] + dp[i][j-1] + … + dp[i][j-a[i]+2] + dp[i][j-a[i]+1] + dp[i][j-a[i]]

・kが0からmin(j-1,a[i])のΣについて

j-1が選ばれた場合   Σ = dp[i][j-1] + dp[i][j-2] + … + dp[i][j-1-j+2] + dp[i][j-1-j+1]
                                                            =1              =0

a[i]が選ばれた場合  Σ = dp[i][j-1] + dp[i][j-2] + … + dp[i][j-1-a[i]+2] + dp[i][j-1-a[i]+1] + dp[i][j-1-a[i]]
                                                           =j-a[i]+1            =j-a[i]             

となる．つまり本の式を見たときに，dp[i][j]が足されるのは分かる．a[i]が選ばれた場合だと-dp[i][j-1-a[i]]されるのも分かる．
問題はj,j-1が選ばれた場合なのだが，そもそも配列の添え字がマイナスになったときは中に入ってる値は0と考える．
そうすると，-dp[i][j-1-a[i]]したら式が合わないように見えるが，minの選び方的にj-1-a[i]<0となる.つまり何も引いてないことになる．
これで式変形の正当性は分かる．

そして元の式のdp[i+1][j]=min(j,a[i])Σdp[i][j-k]を使ってこのjをj-1に変えるとさっきの式変形で出てきたmin(j-1,a[i])Σdp[i][j-1-k]に一致する．
よってdp[i+1][j]=dp[i+1][j-1]+dp[i][j]-dp[i][j-1-a[i]]
が導出できる

そしてどういう風に考えれば式変形できるかを考える．
まず，最初の式でkのループが出てくるのを避けたいので，直前に説明したように，元の式をちょっと変えたもので置き換えてkのループの部分がない状態にしたい(要は漸化式の問題とかでよくあるやつ)
そしてどういう変形のやつで代入するように式変形すればいいかよくわからないように思うが，まずiは変えずにj-1に変えている，これはループ的にjは0から増えていくのでj-1が出てきたとしてもj-1の部分はループ的に既に求まっている部分である．だからj-1を使うΣであるmin(j-1,a[i])Σdp[i][j-1]を使えばいい(このΣを頑張って思いつくって感じ)．このΣと元のΣを分解すれば，あとは式の正当性を示す時の感じで順番にやっていけばいい．

つまり，いきなり式変形するのではなく，どういう形に持って行くかを考えて，それに使うΣを思いついて，それを分解することで式変形していけばいい，正直いきなり式変形するのは無理があるから．