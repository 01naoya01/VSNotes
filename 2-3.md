---
tags:
    - AntBook
---


・p54の漸化式に置き換えても計算量が同じなのは，表のiとjは品物の数と重さを表していて，それを掛け算すれば表のマスの数と同じ数になる，つまり表を作るための計算と同じになる，だからO(nW)

・LCSは問題文をちゃんと読んだ方がいい，部分文字列は連続した文字列である必要がないことに注意しないといけない
LCSの漸化式についてだが，(それ以外)のところは問題ないが，(s_i+1=t_j+1)の場合のところは，dp[i][j+1]とdp[i+1][j]は省略してよい

//個数制限なしナップサック問題について
ナップサック問題を見ればわかるが，漸化式と用いた動的計画法で解く場合，考え方として，dp[i+1][j]=i番目までの品物から重さの総和がj以下となるように選んだもの，とある．要するに1ずつjを増加させ，その時その時の最大を求めていく感じである．そして最終的にj=wの場合の最大が元々求めたかったものなので正解になる．この感じはメモ化と同じような感覚である．

p59の式について考える．この最初の式の

dp[i+1][j]=max{dp[i][j-k×w[i]]+k×v[i] | 0<=k}

この式をどうしたいかというと，kのループが嫌なのでこれをなくしたい．これは漸化式なので，漸化式を解くという基本的な気持ちに戻って考える，つまりこの式を式変形して，この式を利用するようにすればよい
この文で意味は分からないかもしれないが，以下を見れば分かるんじゃないかと思う．

dp[i+1][j]=max{dp[i][j-k×w[i]]+k×v[i] | 0<=k} = max(dp[i][j],max{dp[i][j-k×w[i]]+k×v[i] | 1<=k>})       …☆

この式変形は，単純にk=0だった場合についてmaxで分けてるだけである.この状態で，maxの右だけを変形して0<=kにすれば，元の式の形式になるので代入できる．(要するに次は0<=kを目指す>)

=max(dp[i][j],max{dp[i][(j-w[i])-k×w[i]] | 0<=k>}+v[i])

これはなぜこうなるかというと，式変形の目的からすれば，☆の式のk=1の場合が上の式のk=0の場合に一致するようにすればいい☆でk=1の場合はmaxの中は　dp[i][j-w[i]]+v[i]となる．これが目指す式(つまり上の式)のk=0の場合である．よって上のような式になる．v[i]が外に出せるのは，maxなので全部にv[i]足されてるもののmaxなのでv[i]を外に出しても問題は全くない．

そして次はmaxの中のmaxを最初の式の形式になっていることに気づいて代入する
つまり  dp[i+1][j-w[i]]+v[i]=max{dp[i][(j-w[i])-k×w[i]]+k×v[i] | 0<=k}+v[i]   であることに気づく，そして代入すると

=max(dp[i][j],dp[i+1][j-w[i]]+v[i])となる

・配列の再利用の話は，要するに漸化式の表を見れば分かるが，→の向き的に1行のみ保持してる状態でもなんとかなるから，再利用といわれている．ループの向きが違うのはその表の矢印の向きが逆だからである．
再利用という言葉の意味はそういう感じである．中に入ってる値を再利用というよりは，メモリ的な意味でもう一回その領域を使うって感じである．そういう意味が分かればコラムの再利用も本の説明も読んだうえで，なんとなく分かると思う．


・01ナップサックその2についてだが，なぜINFが必要かというと，今まではj以下だったから組合せがないってことはないけど，今回はjに指定してるからこういうことになる．なぜ今回はjに指定してるかというと，今回は価値をjにしてる．今までは重さをjにしてて，重さの制限があったからj以下という風にしていたけど，価値に制限があるわけではないので価値がj以下とかにすると求めるのは最小の重さになるので，中に入る値が小さい値ばっかりになってしまう．だからjに指定してる．
最後のansの求め方でdp[num][i]になっている．numは固定しないといけない理由は，要するにnum個の品物を選んだ時の合計価値iの場合の最小の重さが中にはいってて，その重さが制限を満たしてて一番大きい価値iをansにいれているからである．

P62のboolをDPにしたやつの計算量を考える．ループのnとKを逆にすると考えやすいのだが，逆にすればO(Knm_i)となる．各iのm_iがn個あるのだからO(KΣm)になる
改良版の説明はソースコードに追記してる

P64の下の解き方は，ソースコードを見れば分かると思うが，i < jを保った状態で，dp[i-1]よりも大きいdata[j]に対してdp[i]の中にminを取っている．dp[i-1]の意味は長さがiであるような増加部分列における最終要素の最小値であるから．だからそのiより添え字が大きく値も大きくて最小の要素を入れてる．
lower_boundを使う方法は本を読めばわかると思う．

